## Reading this Documentation

This documentation is structured by API, which is a group of related functionality
like [Geocoding](#geocoding) or [Uploads](#uploads), and then by endpoint, which
is a specific method within that API that performs one action and is located
at a specific URL.

Each endpoint in this documentation is described using several parts:

* The HTTP method: includes GET, POST, PUT, PATCH, DELETE
* The path: for instance, `/geocoding/v5/{mode}/{query}.json`
* URL parameters: these are the parts of the endpoint path wrapped in brackets,
  like `{mode}` in this example.
* Query parameters: contained in a table with an _Option_ header, these are added
  to the query string part of the request.
* A token scope, if one is required.

All URLs referenced in the documentation have the base path `https://api.mapbox.com`.
This base path goes _before_ the endpoint path. In this example, you'd
combine `https://api.mapbox.com` and `/geocoding/v5/{mode}/{query}.json` to get
the request URL `https://api.mapbox.com/geocoding/v5/{mode}/{query}.json`.

For this endpoint, `{mode}` and `{query}` are the URL parameters. In a request,
you replace their placeholders with real values: for instance, you'd choose
`mapbox.places` as your mode and `Chester` as your query, and get the URL
`https://api.mapbox.com/geocoding/v5/mapbox.places/Chester.json`

Query parameters are added to the end of the URL with [query string encoding](https://en.wikipedia.org/wiki/Query_string).
If you wanted to add the `country` query parameter to that Geocoding request, you'd
the query string `?country=us` to the end of the URL, producing
`https://api.mapbox.com/geocoding/v5/mapbox.places/Chester.json?country=us`.

All endpoints require an access token, which is provided as a query parameter.
So the final geocoding request you would construct would look like
`https://api.mapbox.com/geocoding/v5/mapbox.places/Chester.json?country=us&access_token=pk.my-token-value`
The next section covers how you get and use access tokens.

```http
https://api.mapbox.com
```

## Access tokens

Access to Mapbox web services requires an [access token](https://mapbox.com/help/define-access-token) that connects API
requests to your account. The example requests in this documentation don't include
an access token: you will need to supply one using the `access_token` query
option or by specifying the token in the SDK or library.

Your default access token is available on your
[Account Dashboard](https://www.mapbox.com/account). You can also manage
and create additional tokens on your [Access tokens page](https://www.mapbox.com/account/access-tokens/) or with the [Tokens API](#tokens).

#### Access token example

```http
https://api.mapbox.com/{endpoint}?access_token={your_access_token}
```

When creating a new access token, you have the option of adding one or more **scopes**.
Each scope adds a different permission to the token, allowing it to be used to
access restricted APIs. Throughout the documentation, we specify the scope
required to access each endpoint.

## Versioning

Each Mapbox API is versioned with a version string specified in the base URL that
can be incremented independently from other APIs.

#### Versioning example

```http
https://api.mapbox.com/{api}/{version}
```

_The [Maps API](#maps) is an exception: its endpoint is prefixed
with `/v4/{map_id}` instead of putting the version after the API name.
This mismatch will be fixed in the next API version._

Using the newest available API is always encouraged.

These changes are considered backwards compatible and will
not require the version string to be incremented:

- Adding properties to JSON objects.
- Changing the number of items returned in a single listing request.
- Changing rate limiting thresholds.
- The structure or length of identifiers generated by the API.
- Changing error messages.

These changes are considered backwards incompatible and will require
the version string to be incremented:

- Removing properties from JSON objects.
- Changing an API's URL structure

In the event that certain functionality is deprecated, we will give at least
90 days notice via email. You will only receive a deprecation email if we
detect you are using part of the API that is being deprecated.

## Rate limits

Mapbox APIs have rate limits that cap the number of requests
that can be made against an endpoint. If you exceed a rate limit, your
request will be throttled and you will receive `HTTP 429 Too Many Requests`
responses from the API.

| Header | Description |
| --- | --- |
| `X-Rate-Limit-Interval` | Length of rate-limiting interval in seconds. |
| `X-Rate-Limit-Limit` | Maximum number of requests you may make in the current interval before reaching the limit. |
| `X-Rate-Limit-Reset` | Unix timestamp of when the current interval will end and the ratelimit counter is reset.|

## CORS

Mapbox web services support [Cross-Origin
Requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS) with no domain restrictions.
To support Internet Explorer 8 and 9, use a library that falls back to
XDomainRequest, like [corslite](https://github.com/mapbox/corslite/).

## Retina

```http
# 一张400x200静态地图
https://api.mapbox.com/v4/mapbox.dark/-76.9,38.9,5/400x200.png?access_token={your_access_token}

# 相同的静态地图Retina
# 显示：这个图像将是800x400
# 像素，但是显示相同的内容
# 比例缩小后看起来也一样
https://api.mapbox.com/v4/mapbox.dark/-76.9,38.9,5/400x200@2x.png?access_token={your_access_token}
```

Mapbox支持所有提供图像的APIs上的Retina图像输出。
在URL上的文件扩展名之前添加`@2x`，以双倍比例请求图像。
例如， 一张带有`@2x`的256×256像素的地图瓦片将是
512×512像素，但显示相同的内容。
当在页面上显示时，图像的大小仍将为256×256像素，
但原始的4个像素将以屏幕单元表示1个像素。

URL的`@2x`部分先于整个格式，
因此以`.png`结尾的URL将以`@2x.png`作为Retina图像的结尾。

唯一不能在Retina比例上使用的资源是TileMill上传的tilesets
或MBTiles。

## HTTPS

我们推荐通过HTTPS来访问Mapbox。
除Maps API外，通过HTTP启动的请求会自动升级为HTTPS。

## Pagination

```curl
Link: <https://api.mapbox.com/uploads/v1/1454024795582?start=cijywvxlm004rtikohhqf99jv&limit=100>; rel="next"
```

分页允许您使用多个请求从API列出许多对象。
在接收到一页对象之后，
可以使用响应的 [`Link` header](http://tools.ietf.org/html/rfc5988) 中的 `下一个` 链接关系来请求下一页。
可以重复此过程，
直到服务器发送没有`链接`头或没有`下一个`链接关系的响应，
这表示集合的结束。

您的应用程序 *必须* 使用`链接`标头进行分页，
而不是构建您自己的URLs，因为用于分页的特定URLs可能随时更改。
[Python requests library](http://docs.python-requests.org/en/master/user/advanced/#link-headers),
和
[link-header-parser module for JavaScript](https://github.com/thlorenz/parse-link-header)
能解析链接头。链接头符合 [RFC 5988 specifications](http://tools.ietf.org/html/rfc5988) 规范。

在[Datasets](#datasets), [Uploads](#uploads), [Styles](#styles), [Tilesets](#tilesets), 和 [Tokens](#tokens) 列表终端点上支持分页。

| 查询参数 | 说明 |
| --- | --- |
| `限制` | 要返回对象的*最大*数。API将尝试返回对象的请求数，但是接收更少的对象并不一定意味着集合的结束。接收没有`链接`头或没有`下一个`链接关系的响应是确定何时处于集合末尾的唯一方法。 |

## Dates

API返回的大多数日期和时间都
以[RFC 3339](https://tools.ietf.org/html/rfc3339) 格式表示，可以通过
[JavaScript Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)
构造函数，[Python arrow library](https://github.com/crsmithdev/arrow)，
以及许多其他库和语言进行解析。 

```javascript
var parsedDate = new Date('2014-11-21T19:41:10.000Z');
```

```python
import arrow
arrow.get('2014-11-21T19:41:10.000Z')
<Arrow [2014-11-21T19:41:10+00:00]>
```

```objc
@import Foundation;

NSDateFormatter *RFC3339DateFormatter = [[NSDateFormatter alloc] init];
RFC3339DateFormatter.locale = [NSLocale localeWithLocaleIdentifier:@"en_US_POSIX"];
RFC3339DateFormatter.dateFormat = @"yyyy-MM-dd'T'HH:mm:ssZZZZZ";
RFC3339DateFormatter.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0];

NSDate *date = [RFC3339DateFormatter dateFromString:@"2014-11-21T19:41:10.000Z"];
```

```swift
import Foundation

let rfc3339DateFormatter = DateFormatter()
rfc3339DateFormatter.locale = Locale(identifier: "en_US_POSIX")
rfc3339DateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssZZZZZ"
rfc3339DateFormatter.timeZone = TimeZone(secondsFromGMT: 0)

let date = rfc3339DateFormatter.date(from: "2014-11-21T19:41:10.000Z")
```

此规则的唯一例外是 [Retrieve TileJSON metadata](#retrieve-tilejson-metadata)
终端点，它将`创建`和`修改`的属性作为 [Unix time](https://en.wikipedia.org/wiki/Unix_time) 返回。

```objc
@import Foundation;

NSDate *date = [NSDate dateWithTimeIntervalSince1970:1416598870000];
```

```swift
import Foundation

let date = Date(timeIntervalSince1970: 1_416_598_870_000)
```

## Coordinates

如果地理坐标提供给Mapbox API，
则应按照`经度，纬度`的顺序对其进行格式化，并在WGS84坐标系中指定为十进制度。
这种模式符合现有标准，包括GeoJSON和KML。

Mapbox APIs use GeoJSON formatting wherever possible to represent Mapbox APIs尽可能使用GeoJSON格式来表示
geospatial data. 地理空间数据。方向，地图匹配，地理编码和数据集APIs The Directions, Map Matching, Geocoding, and Datasets APIs
都返回GeoJSON格式的响应，all return GeoJSON-formatted responses, and the Upload and Map Matching APIs
accept GeoJSON input.上传和地图匹配APIs都接受GeoJSON输入。

唯一例外的`经度，纬度`顺序是多段线，
在静态（经典）叠加和路线响应支持。 当指定多段线
输入或输出时，多段线内容应遵循Google编码多段线格式，
该格式指定`纬度，经度`顺序。

Mapbox Swift库使用了核心位置框架的
[`CLLocationCoordinate2D`](https://developer.apple.com/reference/corelocation/cllocationcoordinate2d)
类型来表示地理坐标。初始化
`CLLocationCoordinate2D`时，始终在经度之前指定纬度。

```objc
@import CoreLocation;

CLLocationCoordinate2D coord = CLLocationCoordinate2DMake(38.9099711, -77.0361122);
```

```swift
import CoreLocation

let coord = CLLocationCoordinate2D(latitude: 38.9099711, longitude: -77.0361122)
```
